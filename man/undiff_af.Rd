% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/undiff_af.R
\name{undiff_af}
\alias{undiff_af}
\title{Undifferentiate an allele distribution}
\usage{
undiff_af(p, F, distr = c("auto", "uniform", "beta", "point"), alpha = 1)
}
\arguments{
\item{p}{A vector of observed allele frequencies.}

\item{F}{The FST value of the differentiation to reverse.}

\item{distr}{Name of the mixing distribution to use.
\itemize{
\item "auto" picks a symmetric Beta distribution with parameters that ensure a small enough variance to succeed.
\item "beta" is a symmetric Beta distribution with parameter \code{alpha} as provided below.
\item "uniform" is a uniform distribution (same as "beta" with \code{alpha = beta = 1}).
\item "point" is a distribution fully concentrated/fixed at 0.5 (same as the limit of "beta" with \code{alpha = beta = Inf}, which has zero variance).
}}

\item{alpha}{Shape parameter for \code{distr = "beta"}, ignored otherwise.}
}
\value{
A list with two named elements:
\itemize{
\item \code{p}: A new vector of allele frequencies with the same length as \code{p}, with the desired variance (see below) obtained by weighing the input \code{p} with new random data from distribution \code{distr}.
\item \code{w}: The weight used for the input data (\code{1-w} for the mixing distribution).
}
}
\description{
This function takes a vector of allele frequencies and an FST value, and returns a new distribution of allele frequencies that is consistent with reversing differentiation with the given FST, in the sense that the new distribution is more concentrated around the middle (0.5) than the input/original by an amount predicted from theory.
The new distribution is created by weighing the input distribution with a random mixing distribution with a lower variance.
An automatic method is provided that always selects a Beta distribution with just the right concentration to work for the given data and FST.
Explicit methods are also provided for more control, but are more likely to result in errors when mixing variances are not small enough (see details below).
}
\details{
Model: Suppose we started from an allele frequency \code{p0} with expectation 0.5 and variance \code{V0}.
Differentiation creates a new allele frequency \code{p1} without changing its mean (\code{E(p1|p0) = p0}) and with a conditional variance given by FST \code{F}: \code{Var(p1|p0) = p0*(1-p0)*F}.
The total variance of the new distribution (calculated using the law of total variance) equals
\code{V1 = Var(p1) = F/4 + (1-F)*V0}.
(Also \code{E(p1) = 0.5}).
So the new variance is greater for \code{F>0} (note \code{V0 <= 1/4} for any distribution bounded in (0,1)).
Thus, given \code{V1} and \code{F}, the goal is to construct a new distribution with the original, lower variance of \code{V0 = (V1-F/4)/(1-F)}.
An error is thrown if \code{V1 < F/4} in input data, which is inconsistent with this assumed model.

Construction of "undifferentiated" allele frequencies:
\code{p3 = w*p + (1-w)*p2}, where \code{p} is the input with sample variance \code{V1} and \code{p2} is a random draw from the mixing distribution \code{distr} with expectation 0.5 and known variance \code{V2}.
The output variance is \code{V3 = w^2*V1 + (1-w)^2*V2}, which we set to the desired \code{V0 = (V1-F/4)/(1-F)} and solve for \code{w} (the largest of the two quadratic roots is used).
An error is thrown if \code{V2 > V0} (the output variance must be larger than the mixing variance).
This error is avoided by manually adjusting choice of \code{distr} and \code{alpha} (for \code{distr = "beta"}), or preferably with \code{distr = "auto"} (default), which selects a Beta distribution with \code{alpha = (1/(4*V0)-1)/2} that is guaranteed to work for any valid \code{V0} (assuming \code{V1 < F/4}).
}
\examples{
# create random uniform data for these many loci
m <- 100
p <- runif( m )
# differentiate the distribution using Balding-Nichols model
F <- 0.1
nu <- 1 / F - 1
p2 <- rbeta( m, p * nu, (1 - p) * nu )

# now undifferentiate with this function
# default "automatic" distribution recommended
# (avoids possible errors for specific distributions)
p3 <- undiff_af( p2, F )$p

# note p3 does not equal p (original is unrecoverable)
# but variances (assuming expectation is 0.5 for all) should be close to each other,
# and both be lower than p2's variance:
V1 <- mean( ( p - 0.5 )^2 )
V2 <- mean( ( p2 - 0.5 )^2 )
V3 <- mean( ( p3 - 0.5 )^2 )
# so p3 is stochastically consistent with p as far as the variance is concerned

}
